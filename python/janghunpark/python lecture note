docker : 사용하는 프로그램의 버전을 맞춰줄 수 있는 것
개발자는 Docker를 사용하여 거의 모든 곳에서 실행할 수 있는 경량의, 이식성을 갖춘, 자립형 컨테이너형 애플리케이션을 손쉽게 빌드, 패키징, 제공 및 실행할 수 있습니다. 컨테이너를 사용하면 개발자가 모든 종속성으로 애플리케이션을 패키징하고 단일 단위로 배포할 수 있습니다. 사전에 구축되고 자체적으로 유지되는 애플리케이션 컨테이너를 제공함으로써 개발자는 기본 운영체제 또는 배포 시스템에 대한 걱정 없이 애플리케이션 코드 및 사용성에만 집중할 수 있습니다.

TCP? UDP?

네트워크를 타고 날아갔다가 돌아오는 데에 사용되는 것이 포트 번호 3306임(MySQL <-- 이것을 어떻게 아나?)
이 컴퓨터의 IP
192.168.20.3
포트 번호는 동일하게 3306 
사용하지 않는 포트의 경우 1~3분 정도 기다리면 초기화
리눅스의 경우 사용할 수 있는 포트가 6만개 이상, 배열 형태로 관리하고 있음
어떤 것이 사용 중이고 사용 중이지 않음을 알 수 있음

프로그램을 돌린다 = 메모리에 올린다
task가 있고 thread들도 별도의 task로 구분되어 있음
우리가 만들 서버는 곧 프로세스다, 서버는 절대 죽으면 안 된다. -> Demon process로 만들어야 함
Pid = process id, ppid = parent pid
TTY가 ?로 붙어 있는 애들은 터미널이 꺼져도 계속 구동되는 demon이 됨
대표적인 demon = ctrl + alt + delete = 작업관리자, 강제종료 = paladin 호출

mysql에 접근하기 위해서
pid를 찾아서 init 하면 

새로운 도메인으로 들어가는 것이기 때문에 일단 만들어보고 어떤 문제가 생기는지 파악

IoC로 인해 변경에 대한 유연함이 확보, 비용이 줄어듦
심지어 알고 있는 것이 아니기 때문에 그냥 layer만 구성해놓고 일단 가는 것임
추후 필요한 것이 발생 시 refactoring을 하는 것임

DDD 할 때 관심사의 분리
mocking 을 해버리면 내가 필요한 것은 다 있다고 가정하고 test 를 할 수 있음

우리 프로젝트와도 관련, 동기/비동기 데이터에 대한 처리를 잘 할 필요가 있음
blocking / non-blocking

---------------------------------------------------------------------------------

231220
config 를 통해 IP, 비밀번호, PORT 번호 등을 환경 변수로 만들어 외부로의 노출을 막아야 함
사용 목적도 알아야 하며 사용 방법 역시 알아야 함

env 설정
githun_action = 서비스 배포하는 것과 관련, AWS에 업로드되는 것을 자동화하는 등 생산성을 높임
디지털 노가다를 방지할 수 있음
secret 설정들을 하면 자동화된 프로그램만이 해당 정보를 참고하도록 관리 가능

도메인을 검색해서 들어오면 그에 맞는 IP를 타고 옴

무엇을 응답할 것인가, 어디로 응답할 것인가

---------------------------------------------------------------------------------

< 231221 >

1. custom_protocol setting
1) singletonCreation test ; TDD 하는 것 잊지 말기
2) python 에서는 test 할 때 반드시 method 명 맨 앞에 test 를 붙여야 합니다.
3) register : 이전에 만들었던 table 과 유사한 형식의 method (직접 구현한 것)
4) C++ 코딩할 때 private 과 public method 호출 방식이 어떻게 달랐는지 복습
5) **argument? *는 포인터가 아니라.. 
6) append() : 리스트의 원소를 하나씩 추가할 때 사용
7) protocolTable = 이전의 함수 포인터 테이블 같은데 ?
8) key, value 를 한 세트로 가지고 있는 것을 Map 이라고 함 -> ** 을 사용해서 받을 수 있음

2. console_ui setting
1) 시나리오 구성을 하고 들어가자 
2) currentReadNumber 는 실제로 필요함 -> 강사님 board 복습하자
3) Keyboardinput 을 받는 것은 혁명이다...
4) 뭔가 input 을 받았을 때 그 정보가 하위 계층으로 전달되어야 하는가 생각

- transmitter, receiver 파일은 아직 복붙 안함 (복습하면서 따라갈 것)
receiver 에서 받은 정보를 바탕으로 queue(메모리를 공유하지 않으면서 정보를 전달하는 방식) 를 만들어서 ui task 에 전달
lock 을 걸었던 것은 자원이 공유되고 있는데 동시에 사용될 수 있는 상황 -> 실제로 socket 은 transmitter 와 receiver 가 공유를 하고 있으므로 설정했던 것임 
thread pool 구성은 원래 필요하긴 한데 rust 가서..
- 주기(transmit), 받기(receive), 뿌리기(print)

---------------------------------------------------------------------------------

상품 결제 사이트
- Account : 
- Product : 
- Order : 누가 주문한 것인지 확인도 가능, server-DB 가 따로 있어야 함

세션 정보를 저장하기 위해 UI repo 에서 사용자의 고유 ID 바탕으로 세션을 가지고 있음

init~~Alternatives 를 쓰면 entity 를 던지면 알아서 처리를 해준다는 것이 이점임
만약 entity를 일일이 작업을 해야 하는 식 (이전 방식) 보다 비용이 줄어듦

지금까지는 추상화하는 방식을 배운 것, 이제부터는 조금씩 추상화된 라이브러리를 씀

privat : 웬만하면 바뀌지 않는 것
protected : 

ID 중복체크 기능도 있어야 함 

command + Network = protocol
command = UI 내부에서만 돌릴 경우
UI에서 . , ' " 가 들어오면 루프 돌려버리기

url ; 뭔가 했다 -> 

